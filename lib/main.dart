// lib/main.dart
import 'package:cloud_firestore/cloud_firestore.dart'; // Import for Firestore
import 'package:cloud_functions/cloud_functions.dart'; // Import for Functions
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/foundation.dart'; // For kDebugMode and defaultTargetPlatform
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart'; // For BlocProvider
import 'package:gymgenius/providers/workout_session_manager.dart'; // Global WorkoutSessionManager
import 'package:gymgenius/screens/auth/login_screen.dart';
import 'package:gymgenius/screens/auth/signin_screen.dart';
import 'package:gymgenius/screens/home_screen.dart'; // Initial screen for unauthenticated users
import 'package:gymgenius/screens/main_dashboard_screen.dart'; // Main screen for authenticated users
import 'package:gymgenius/screens/onboarding/bloc/onboarding_bloc.dart'; // OnboardingBloc
import 'package:gymgenius/screens/onboarding/onboarding_screen.dart';
import 'package:gymgenius/theme/app_theme.dart'; // Your app's theme
import 'package:provider/provider.dart'; // For ChangeNotifierProvider

// Import firebase_options.dart (generated by FlutterFire CLI)
import 'firebase_options.dart';

// Global flag to control emulator usage.
// kDebugMode is true only when the app is launched in debug mode from an IDE/CLI.
// Set to `false` for production builds or if you don't want emulators in debug.
const bool _useEmulators =
    kDebugMode; // Use emulators only in debug mode by default
// const bool _useEmulators = true; // Force emulators (for testing specific scenarios)
// const bool _useEmulators = false; // Force production services

Future<void> _configureFirebaseEmulators() async {
  // Determine the host IP for emulators.
  // '10.0.2.2' for Android emulators, 'localhost' for iOS simulators/desktop.
  // For physical device testing with emulators, use your computer's local network IP.
  final String host2 = defaultTargetPlatform == TargetPlatform.android
      ? '10.0.2.2'
      : 'localhost';
  // Example for physical device: final host = '192.168.1.100'; // Replace with your PC's IP

  final String host = '192.168.8.46';

  print('--- Configuring Firebase Emulators to connect to: $host ---');

  try {
    // Auth emulator configuration
    await FirebaseAuth.instance.useAuthEmulator(host, 9099);
    print('FirebaseAuth emulator configured on $host:9099');

    // Optionally disable app verification for testing (e.g., phone auth without real SMS)
    // await FirebaseAuth.instance.setSettings(appVerificationDisabledForTesting: true);

    // Firestore emulator configuration
    FirebaseFirestore.instance.settings = Settings(
      host: '$host:8080',
      sslEnabled: false, // SSL is typically disabled for local emulators
      persistenceEnabled:
          false, // Disable persistence for cleaner emulator testing if desired
    );
    // An alternative way for Firestore emulator:
    // FirebaseFirestore.instance.useFirestoreEmulator(host, 8080);
    print('FirebaseFirestore emulator configured on $host:8080');

    // Functions emulator configuration
    FirebaseFunctions.instance.useFunctionsEmulator(host, 5001);
    print('FirebaseFunctions emulator configured on $host:5001');

    print('--- Firebase Emulators configured successfully ---');
  } catch (e, stack) {
    print('Error configuring Firebase emulators: $e');
    print(stack);
    // Consider re-throwing or handling this error more gracefully if emulator setup is critical.
  }
}

// Test function for authentication (can be removed or adapted for specific tests).
Future<void> _testAuthEmulatorConnectivity() async {
  if (!_useEmulators) return; // Only run if emulators are configured

  try {
    final email =
        'emulatortest${DateTime.now().millisecondsSinceEpoch}@example.com';
    print('Attempting to create test user for emulator: $email');

    final credential =
        await FirebaseAuth.instance.createUserWithEmailAndPassword(
      email: email,
      password: 'password123',
    );
    print(
        'Emulator Test: User created successfully with UID: ${credential.user?.uid}');

    // Optionally, sign out the test user immediately
    // await FirebaseAuth.instance.signOut();
    // print('Emulator Test: Test user signed out.');
  } catch (e, stack) {
    print('Emulator Test: Authentication test failed: $e');
    // print(stack); // Full stack trace can be noisy, enable if needed
  }
}

Future<void> main() async {
  // Ensure Flutter bindings are initialized before calling native code.
  WidgetsFlutterBinding.ensureInitialized();

  // Initialize Firebase with platform-specific options.
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );

  // Configure Firebase emulators if _useEmulators is true.
  if (_useEmulators) {
    await _configureFirebaseEmulators();
    // Optionally run a quick connectivity test after configuring emulators
    // This should be called after _configureFirebaseEmulators
    // WidgetsBinding.instance.addPostFrameCallback((_) {
    //   _testAuthEmulatorConnectivity();
    // });
  } else {
    print("--- Using Production Firebase Services ---");
  }

  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    // Provide WorkoutSessionManager globally using ChangeNotifierProvider.
    return ChangeNotifierProvider(
      create: (context) => WorkoutSessionManager(), // Global instance
      child: MaterialApp(
        title: 'GymGenius',
        theme: AppTheme.darkTheme, // Apply the custom dark theme
        debugShowCheckedModeBanner: false, // Hide the debug banner

        // The AuthWrapper handles the initial screen based on auth state.
        home: const AuthWrapper(),

        // Define named routes for navigation.
        routes: {
          // '/home' is the landing screen for unauthenticated users.
          '/home': (context) => const HomeScreen(),
          '/login': (context) => const LoginScreen(),
          '/signin': (context) {
            // Retrieve arguments passed via Navigator.pushNamed (e.g., onboardingData).
            final args = ModalRoute.of(context)?.settings.arguments
                as Map<String, dynamic>?;
            return SignInScreen(
                onboardingData:
                    args?['onboardingData']); // Pass data if it exists
          },
          // Provide OnboardingBloc specifically for the OnboardingScreen route.
          '/onboarding': (context) => BlocProvider(
                create: (blocContext) => OnboardingBloc(),
                child: const OnboardingScreen(),
              ),
          // '/main_app' is the main dashboard for authenticated users.
          '/main_app': (context) => const MainDashboardScreen(),
        },

        // Optional: Handle unknown routes gracefully.
        onUnknownRoute: (settings) {
          print("Unknown route: ${settings.name}");
          return MaterialPageRoute(builder: (_) => const UnknownRouteScreen());
        },
      ),
    );
  }
}

// AuthWrapper widget determines the initial screen based on Firebase Auth state.
class AuthWrapper extends StatelessWidget {
  const AuthWrapper({super.key});

  // --- NOTE: Logic for checking if onboarding is complete could be moved here ---
  // This would involve fetching user data from Firestore after authentication.
  // Example:
  // Future<bool> _isOnboardingComplete(String userId) async {
  //   final doc = await FirebaseFirestore.instance.collection('users').doc(userId).get();
  //   if (doc.exists && doc.data() != null) {
  //     return (doc.data()!['onboardingData'] as Map<String, dynamic>?)?.isNotEmpty ?? false;
  //   }
  //   return false; // Default to not complete if no data or user doc
  // }

  @override
  Widget build(BuildContext context) {
    // StreamBuilder listens to Firebase Auth state changes.
    return StreamBuilder<User?>(
      stream: FirebaseAuth.instance.authStateChanges(),
      builder: (context, snapshot) {
        // Show a loading indicator while checking auth state.
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Scaffold(
            body: Center(child: CircularProgressIndicator()),
          );
        }
        // Show an error message if auth state check fails.
        if (snapshot.hasError) {
          print("AuthWrapper StreamBuilder error: ${snapshot.error}");
          return Scaffold(
            body: Center(
              child: Padding(
                padding: const EdgeInsets.all(20.0),
                child: Text(
                  "Error verifying authentication: ${snapshot.error}\nPlease try restarting the app.",
                  style: TextStyle(color: Theme.of(context).colorScheme.error),
                  textAlign: TextAlign.center,
                ),
              ),
            ),
          );
        }
        // Redirect based on authentication state.
        if (snapshot.hasData && snapshot.data != null) {
          // User is logged in -> Navigate to MainDashboardScreen.
          // TODO: Consider adding onboarding completion check here.
          // If onboarding is not complete, navigate to OnboardingScreen instead.
          // Example:
          // return FutureBuilder<bool>(
          //   future: _isOnboardingComplete(snapshot.data!.uid),
          //   builder: (context, onboardingSnapshot) {
          //     if (onboardingSnapshot.connectionState == ConnectionState.waiting) {
          //       return const Scaffold(body: Center(child: CircularProgressIndicator()));
          //     }
          //     if (onboardingSnapshot.data == true) {
          //       return const MainDashboardScreen();
          //     } else {
          //       // Need to provide OnboardingBloc here as well if navigating to OnboardingScreen
          //       return BlocProvider(
          //          create: (blocContext) => OnboardingBloc(),
          //          child: const OnboardingScreen(),
          //       );
          //     }
          //   },
          // );
          print(
              "AuthWrapper: User is authenticated (UID: ${snapshot.data!.uid}). Navigating to MainDashboardScreen.");
          return const MainDashboardScreen();
        } else {
          // User is logged out -> Navigate to HomeScreen (landing/login prompt).
          print(
              "AuthWrapper: User is not authenticated. Navigating to HomeScreen.");
          return const HomeScreen();
        }
      },
    );
  }
}

// A simple screen to display for unknown routes (optional).
class UnknownRouteScreen extends StatelessWidget {
  const UnknownRouteScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text("Page Not Found")),
      body: const Center(
        child: Padding(
          padding: EdgeInsets.all(20.0),
          child: Text(
            "Sorry, the page you were looking for could not be found. Please check the URL or return to the previous page.",
            textAlign: TextAlign.center,
          ),
        ),
      ),
    );
  }
}
